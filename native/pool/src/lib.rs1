#[macro_use] extern crate rustler;
#[macro_use] extern crate rustler_codegen;
#[macro_use] extern crate lazy_static;
#[macro_use] extern crate serde_json;

extern crate libc;
extern crate indy;

mod callbacks;
mod utils;
mod results;

use libc::c_char;
use std::ffi::CString;
use indy::api::ErrorCode;
use rustler::{Env, Term, NifResult, Encoder};
use results::{result_to_string, result_to_int, result_to_empty};
use indy::api::Pool::{set_something,set_something_else};

mod atoms {
   rustler_atoms! {
       atom ok;
       atom error;
       //atom __true__ = "true";
       //atom __false__ = "false";
   }
}

rustler_export_nifs! {
   "Elixir.Indy.POOL" ,
("set_something_else", 1, set_something_else),
("set_something", 1, set_something),
,
   None
}

pub fn set_something<'a>(env: Env<'a>, args: &[Term<'a>]) -> NifResult<Term<'a>> {

  let handle: i32 = try!(args[0].decode());

  let (receiver, command_handle, cb) = callbacks::_closure_to_cb_ec();

  let err = indy_set_something(command_handle, handle, cb);

  let response = match result_to_empty(err, receiver) {
      Ok(()) => (atoms::ok(), format!("Success!")),
      Err(err) => (atoms::error(), format!("There was a problem: {:?}", err)),
  };

  Ok(response.encode(env))
}

pub fn set_something_else<'a>(env: Env<'a>, args: &[Term<'a>]) -> NifResult<Term<'a>> {

  let handle: i32 = try!(args[0].decode());

  let (receiver, command_handle, cb) = callbacks::_closure_to_cb_ec();

  let err = indy_set_something_else(command_handle, handle, cb);

  let response = match result_to_empty(err, receiver) {
      Ok(()) => (atoms::ok(), format!("Success!")),
      Err(err) => (atoms::error(), format!("There was a problem: {:?}", err)),
  };

  Ok(response.encode(env))
}



