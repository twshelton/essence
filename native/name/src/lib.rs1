#[macro_use] extern crate rustler;
#[macro_use] extern crate rustler_codegen;
#[macro_use] extern crate lazy_static;
#[macro_use] extern crate serde_json;

extern crate libc;
extern crate indy;

mod callbacks;
mod utils;
mod results;

use libc::c_char;
use std::ffi::CString;
use indy::api::ErrorCode;
use rustler::{Env, Term, NifResult, Encoder};
use results::{result_to_string, result_to_int, result_to_empty};
use indy::api::pool::{indy_close_pool_ledger, indy_refresh_pool_ledger, indy_create_pool_ledger_config,
indy_delete_pool_ledger_config, indy_list_pools, indy_set_protocol_version,indy_open_pool_ledger};

mod atoms {
  rustler_atoms! {
      atom ok;
      atom error;
      //atom __true__ = "true";
      //atom __false__ = "false";
  }
}

rustler_export_nifs! {
  "Elixir.Indy.Pool",
  [
      ("list_pools", 0, list_pools),
      ("set_protocol_version", 1, set_protocol_version),
      ("open_default_pool_ledger", 1, open_default_pool_ledger),
      ("open_pool_ledger", 2, open_pool_ledger),
      ("refresh_pool_ledger", 1, refresh_pool_ledger),
      ("close_pool_ledger", 1, close_pool_ledger),
      ("create_pool_ledger_config", 2, create_pool_ledger_config),
      ("delete_pool_ledger_config", 1, delete_pool_ledger_config)
  ],
  None
}

pub fn close_pool_ledger<'a>(env: Env<'a>, args: &[Term<'a>]) -> NifResult<Term<'a>> {

  let handle: i32 = try!(args[0].decode());

  let (receiver, command_handle, cb) = callbacks::_closure_to_cb_ec();

  let err = indy_close_pool_ledger(command_handle, handle, cb);

  let response = match result_to_empty(err, receiver) {
      Ok(()) => (atoms::ok(), format!("Success!")),
      Err(err) => (atoms::error(), format!("There was a problem closing the pool ledger: {:?}", err)),
  };

  Ok(response.encode(env))
}
